const t="insert",e="update",o="delete",r=Symbol("observable-meta-key"),n={path:1,pathsOf:1,pathsFrom:1},s={[r]:{value:null},observe:{value:function(t,e){if("function"!=typeof t)throw new Error("observer parameter MUST be a function");const o=this[r].observers;if(o.some(e=>e[0]===t))console.info("observer may be bound to an observable only once");else{let r;r=e?function(t){const e={};void 0!==t.path&&("string"!=typeof t.path?console.error('"path" option, if/when provided, MUST be a non-empty string'):e.path=t.path),void 0!==t.pathsOf&&(t.path?console.error('"pathsOf" option MAY NOT be specified together with "path" option'):"string"!=typeof t.pathsOf?console.error('"pathsOf" option, if/when provided, MUST be a non-empty string'):e.pathsOf=t.pathsOf.split(".").filter(t=>t)),void 0!==t.pathsFrom&&(t.path||t.pathsOf?console.error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf"  option/s'):"string"!=typeof t.pathsFrom?console.error('"pathsFrom" option, if/when provided, MUST be a non-empty string'):e.pathsFrom=t.pathsFrom);const o=Object.keys(t).filter(t=>!n.hasOwnProperty(t));return o.length&&console.error(`'${o.join(", ")}' is/are not a valid option/s`),e}(e):{},o.push([t,r])}}},unobserve:{value:function(){const t=this[r].observers;let e=t.length;if(e){let o=arguments.length;if(o)for(;o--;){let r=e;for(;r--;)t[r][0]===arguments[o]&&(t.splice(r,1),e--)}else t.splice(0)}}}},a=function(t,e){s[r].value=e;const o=Object.keys(t),n=Object.defineProperties({},s);let a,i=o.length;for(;i--;)n[a=o[i]]=p(t[a],a,e);return n},i=function(t,e){let o=t.length;s[r].value=e;const n=Object.defineProperties(new Array(o),s);for(;o--;)n[o]=p(t[o],o,e);return n},h=function(t,e){return s[r].value=e,Object.defineProperties(t,s),t},l=function(t,e){let o,r,n,s,a,i,h,l,p,c;const f=e.length;for(;;){for(l=(o=t.observers).length;l--;)try{n=(r=o[l])[0],s=r[1],a=e,s.path?(i=s.path,a=e.filter(t=>t.path.join(".")===i)):s.pathsOf?a=e.filter(t=>t.path.length===s.pathsOf.length+1):s.pathsFrom&&(h=s.pathsFrom,a=e.filter(t=>t.path.join(".").startsWith(h))),a.length&&n(a)}catch(t){console.error(`failed to deliver changes to listener ${n}`,t)}let u;if(!t.parent)break;u=new Array(f);for(let o=0;o<f;o++)c=e[o],p=[t.ownKey,...c.path],u[o]={type:c.type,path:p,value:c.value,oldValue:c.oldValue,object:c.object};e=u,t=t.parent}},p=function(t,e,o){return t&&"object"==typeof t?Array.isArray(t)?new w({target:t,ownKey:e,parent:o}).proxy:ArrayBuffer.isView(t)?new j({target:t,ownKey:e,parent:o}).proxy:t instanceof Date||t instanceof Blob||t instanceof Error?t:new d({target:t,ownKey:e,parent:o}).proxy:t},c=function(){const t=this[r],e=t.target;let o,n,s;for(e.reverse(),o=0,n=e.length;o<n;o++)if((s=e[o])&&"object"==typeof s){const t=s[r];t&&(t.ownKey=o)}return l(t,[{type:"reverse",path:[],object:this}]),this},f=function(t){const e=this[r],o=e.target;let n,s,a;for(o.sort(t),n=0,s=o.length;n<s;n++)if((a=o[n])&&"object"==typeof a){const t=a[r];t&&(t.ownKey=n)}return l(e,[{type:"shuffle",path:[],object:this}]),this},u=function(o,n,s){const a=this[r],i=a.target,h=[],c=i.length,f=i.slice(0);if(n=void 0===n?0:n<0?Math.max(c+n,0):Math.min(n,c),s=void 0===s?c:s<0?Math.max(c+s,0):Math.min(s,c),n<c&&s>n){let c;i.fill(o,n,s);for(let o,l,u=n;u<s;u++)o=i[u],i[u]=p(o,u,a),f.hasOwnProperty(u)?((l=f[u])&&"object"==typeof l&&(c=l[r])&&(l=c.detach()),h.push({type:e,path:[u],value:i[u],oldValue:l,object:this})):h.push({type:t,path:[u],value:i[u],object:this});l(a,h)}return this},y=function(t,o,n){const s=this[r],a=s.target,i=a.length;t=t<0?Math.max(i+t,0):t,o=void 0===o?0:o<0?Math.max(i+o,0):Math.min(o,i),n=void 0===n?i:n<0?Math.max(i+n,0):Math.min(n,i);const h=Math.min(n-o,i-t);if(t<i&&t!==o&&h>0){const i=a.slice(0),c=[];a.copyWithin(t,o,n);for(let o,n,l,f=t;f<t+h;f++)(o=a[f])&&"object"==typeof o&&(o=p(o,f,s),a[f]=o),(n=i[f])&&"object"==typeof n&&(l=n[r])&&(n=l.detach()),"object"!=typeof o&&o===n||c.push({type:e,path:[f],value:o,oldValue:n,object:this});l(s,c)}return this},b={pop:function(){const t=this[r],e=t.target,n=e.length-1;let s=e.pop();if(s&&"object"==typeof s){const t=s[r];t&&(s=t.detach())}return l(t,[{type:o,path:[n],oldValue:s,object:this}]),s},push:function(){const e=this[r],o=e.target,n=arguments.length,s=new Array(n),a=o.length;for(let t=0;t<n;t++)s[t]=p(arguments[t],a+t,e);const i=Reflect.apply(o.push,o,s),h=[];for(let e=a,r=o.length;e<r;e++)h[e-a]={type:t,path:[e],value:o[e],object:this};return l(e,h),i},shift:function(){const t=this[r],e=t.target;let n,s,a,i,h;for((n=e.shift())&&"object"==typeof n&&(h=n[r])&&(n=h.detach()),s=0,a=e.length;s<a;s++)(i=e[s])&&"object"==typeof i&&(h=i[r])&&(h.ownKey=s);return l(t,[{type:o,path:[0],oldValue:n,object:this}]),n},unshift:function(){const e=this[r],o=e.target,n=arguments.length,s=new Array(n);for(let t=0;t<n;t++)s[t]=p(arguments[t],t,e);const a=Reflect.apply(o.unshift,o,s);for(let t,e=0,n=o.length;e<n;e++)if((t=o[e])&&"object"==typeof t){const o=t[r];o&&(o.ownKey=e)}const i=s.length,h=new Array(i);for(let e=0;e<i;e++)h[e]={type:t,path:[e],value:o[e],object:this};return l(e,h),a},reverse:c,sort:f,fill:u,copyWithin:y,splice:function(){const n=this[r],s=n.target,a=arguments.length,i=new Array(a),h=s.length;for(let t=0;t<a;t++)i[t]=p(arguments[t],t,n);const c=0===a?0:i[0]<0?h+i[0]:i[0],f=a<2?h-c:i[1],u=Math.max(a-2,0),y=Reflect.apply(s.splice,s,i),b=s.length;let g,v,d,w;for(let t,e=0;e<b;e++)(t=s[e])&&"object"==typeof t&&(g=t[r])&&(g.ownKey=e);for(v=0,d=y.length;v<d;v++)(w=y[v])&&"object"==typeof w&&(g=w[r])&&(y[v]=g.detach());const j=[];let m;for(m=0;m<f;m++)m<u?j.push({type:e,path:[c+m],value:s[c+m],oldValue:y[m],object:this}):j.push({type:o,path:[c+m],oldValue:y[m],object:this});for(;m<u;m++)j.push({type:t,path:[c+m],value:s[c+m],object:this});return l(n,j),y}},g={reverse:c,sort:f,fill:u,copyWithin:y,set:function(t,o){const n=this[r],s=n.target,a=t.length,i=s.slice(0);o=o||0,s.set(t,o);const h=new Array(a);for(let t=o;t<a+o;t++)h[t-o]={type:e,path:[t],value:s[t],oldValue:i[t],object:this};l(n,h)}};class v{constructor(t,e){const o=t.target,r=t.parent,n=t.ownKey;r&&void 0!==n?(this.parent=r,this.ownKey=n):(this.parent=null,this.ownKey=null);const s=e(o,this);this.observers=[],this.revokable=Proxy.revocable(s,this),this.proxy=this.revokable.proxy,this.target=s}detach(){return this.parent=null,this.target}set(o,n,s){let a=o[n];if(s!==a){const i=p(s,n,this);if(o[n]=i,a&&"object"==typeof a){const t=a[r];t&&(a=t.detach())}const h=void 0===a?[{type:t,path:[n],value:i,object:this.proxy}]:[{type:e,path:[n],value:i,oldValue:a,object:this.proxy}];l(this,h)}return!0}deleteProperty(t,e){let n=t[e];if(delete t[e],n&&"object"==typeof n){const t=n[r];t&&(n=t.detach())}const s=[{type:o,path:[e],oldValue:n,object:this.proxy}];return l(this,s),!0}}class d extends v{constructor(t){super(t,a)}}class w extends v{constructor(t){super(t,i)}get(t,e){return b.hasOwnProperty(e)?b[e]:t[e]}}class j extends v{constructor(t){super(t,h)}get(t,e){return g.hasOwnProperty(e)?g[e]:t[e]}}class m{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(t){if(t&&"object"==typeof t){if(t[r])return t;if(Array.isArray(t))return new w({target:t,ownKey:null,parent:null}).proxy;if(ArrayBuffer.isView(t))return new j({target:t,ownKey:null,parent:null}).proxy;if(t instanceof Date||t instanceof Blob||t instanceof Error)throw new Error(`${t} found to be one of non-observable types`);return new d({target:t,ownKey:null,parent:null}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")}static isObservable(t){return!(!t||!t[r])}}Object.freeze(m);export{m as Observable};