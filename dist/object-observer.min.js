const e="insert",t="update",o="delete",r=Symbol("observable-meta-key"),n={path:1,pathsOf:1,pathsFrom:1},s=function(e,t){if("function"!=typeof e)throw new Error("observer parameter MUST be a function");const o=this[r].observers;if(o.some(t=>t[0]===e))console.info("observer may be bound to an observable only once");else{let r;r=t?function(e){const t={};void 0!==e.path&&("string"!=typeof e.path?console.error('"path" option, if/when provided, MUST be a non-empty string'):t.path=e.path),void 0!==e.pathsOf&&(e.path?console.error('"pathsOf" option MAY NOT be specified together with "path" option'):"string"!=typeof e.pathsOf?console.error('"pathsOf" option, if/when provided, MUST be a non-empty string'):t.pathsOf=e.pathsOf.split(".").filter(e=>e)),void 0!==e.pathsFrom&&(e.path||e.pathsOf?console.error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf"  option/s'):"string"!=typeof e.pathsFrom?console.error('"pathsFrom" option, if/when provided, MUST be a non-empty string'):t.pathsFrom=e.pathsFrom);const o=Object.keys(e).filter(e=>!n.hasOwnProperty(e));return o.length&&console.error(`'${o.join(", ")}' is/are not a valid option/s`),t}(t):{},o.push([e,r])}},p=function(){const e=this[r].observers;let t=e.length;if(t){let o=arguments.length;if(o)for(;o--;){let r=t;for(;r--;)e[r][0]===arguments[o]&&(e.splice(r,1),t--)}else e.splice(0)}},a=function(e,t){let o,n=e.length;const a=Object.defineProperties(new Array(n),{[r]:{value:t},observe:{value:s},unobserve:{value:p}});for(;n--;)o=e[n],a[n]=o&&"object"==typeof o?h(o,n,t):o;return a},l=function(e,t){const o=Object.keys(e),n=Object.defineProperties({},{[r]:{value:t},observe:{value:s},unobserve:{value:p}});let a,l,c=o.length;for(;c--;)l=e[a=o[c]],n[a]=l&&"object"==typeof l?h(l,a,t):l;return n},c=function(e,t){let o,r,n,s,p,a,l,c,h,i;const f=t.length;for(;;){for(c=(o=e.observers).length;c--;)try{n=(r=o[c])[0],s=r[1],p=t,s.path?(a=s.path,p=t.filter(e=>e.path.join(".")===a)):s.pathsOf?p=t.filter(e=>e.path.length===s.pathsOf.length+1):s.pathsFrom&&(l=s.pathsFrom,p=t.filter(e=>e.path.join(".").startsWith(l))),p.length&&n(p)}catch(e){console.error(`failed to deliver changes to listener ${n}`,e)}let y;if(!e.parent)break;y=new Array(f);for(let o=0;o<f;o++)i=t[o],h=[e.ownKey],Array.prototype.push.apply(h,i.path),y[o]={type:i.type,path:h,value:i.value,oldValue:i.oldValue,object:i.object};t=y,e=e.parent}},h=function(e,t,o){return e&&"object"==typeof e?Array.isArray(e)?new y({target:e,ownKey:t,parent:o}).proxy:e instanceof Date||e instanceof Blob||e instanceof Error?e:new u({target:e,ownKey:t,parent:o}).proxy:e},i={pop:function(e,t){const n=e.length-1;let s=e.pop();if(s&&"object"==typeof s){const e=s[r];e&&(s=e.detach())}const p=[{type:o,path:[n],oldValue:s,object:t.proxy}];return c(t,p),s},push:function(t,o){const r=arguments.length-2,n=new Array(r),s=t.length;let p;for(let e=0;e<r;e++)p=arguments[e+2],n[e]=h(p,s+e,o);const a=Reflect.apply(t.push,t,n),l=[];for(let r=s,n=t.length;r<n;r++)l[r-s]={type:e,path:[r],value:t[r],object:o.proxy};return c(o,l),a},shift:function(e,t){let n,s,p,a,l;for((n=e.shift())&&"object"==typeof n&&(l=n[r])&&(n=l.detach()),s=0,p=e.length;s<p;s++)(a=e[s])&&"object"==typeof a&&(l=a[r])&&(l.ownKey=s);const h=[{type:o,path:[0],oldValue:n,object:t.proxy}];return c(t,h),n},unshift:function(t,o){const n=Array.from(arguments);n.splice(0,2),n.forEach((e,t)=>{n[t]=h(e,t,o)});const s=Reflect.apply(t.unshift,t,n);for(let e,o=0,n=t.length;o<n;o++)if((e=t[o])&&"object"==typeof e){const t=e[r];t&&(t.ownKey=o)}const p=n.length,a=new Array(p);for(let r=0;r<p;r++)a[r]={type:e,path:[r],value:t[r],object:o.proxy};return c(o,a),s},reverse:function(e,t){let o,n,s;for(e.reverse(),o=0,n=e.length;o<n;o++)if((s=e[o])&&"object"==typeof s){const e=s[r];e&&(e.ownKey=o)}const p=[{type:"reverse",path:[],object:t.proxy}];return c(t,p),t.proxy},sort:function(e,t,o){let n,s,p;for(e.sort(o),n=0,s=e.length;n<s;n++)if((p=e[n])&&"object"==typeof p){const e=p[r];e&&(e.ownKey=n)}const a=[{type:"shuffle",path:[],object:t.proxy}];return c(t,a),t.proxy},fill:function(o,n){const s=[],p=o.length,a=Array.from(arguments);a.splice(0,2);const l=a.length,i=l<2?0:a[1]<0?p+a[1]:a[1],f=l<3?p:a[2]<0?p+a[2]:a[2],y=o.slice(0);let u;Reflect.apply(o.fill,o,a);for(let p,a,l=i;l<f;l++)p=o[l],o[l]=h(p,l,n),y.hasOwnProperty(l)?((a=y[l])&&"object"==typeof a&&(u=a[r])&&(a=u.detach()),s.push({type:t,path:[l],value:o[l],oldValue:a,object:n.proxy})):s.push({type:e,path:[l],value:o[l],object:n.proxy});return c(n,s),n.proxy},splice:function(n,s){const p=Array.from(arguments),a=n.length;p.splice(0,2);const l=p.length;for(let e,t=2;t<l;t++)e=p[t],p[t]=h(e,t,s);const i=0===l?0:p[0]<0?a+p[0]:p[0],f=l<2?a-i:p[1],y=Math.max(l-2,0),u=Reflect.apply(n.splice,n,p),b=n.length;let v,d,g,j;for(let e,t=0;t<b;t++)(e=n[t])&&"object"==typeof e&&(v=e[r])&&(v.ownKey=t);for(d=0,g=u.length;d<g;d++)(j=u[d])&&"object"==typeof j&&(v=j[r])&&(u[d]=v.detach());const w=[];let x;for(x=0;x<f;x++)x<y?w.push({type:t,path:[i+x],value:n[i+x],oldValue:u[x],object:s.proxy}):w.push({type:o,path:[i+x],oldValue:u[x],object:s.proxy});for(;x<y;x++)w.push({type:e,path:[i+x],value:n[i+x],object:s.proxy});return c(s,w),u}};class f{constructor(e,t){const o=e.target,r=e.parent,n=e.ownKey;r&&void 0!==n?(this.parent=r,this.ownKey=n):(this.parent=null,this.ownKey=null);const s=t(o,this);this.observers=[],this.revokable=Proxy.revocable(s,this),this.proxy=this.revokable.proxy,this.target=s}set(o,n,s){let p=o[n];if(s===p)return!0;const a=h(s,n,this);if(o[n]=a,p&&"object"==typeof p){const e=p[r];e&&(p=e.detach())}const l=void 0===p?[{type:e,path:[n],value:a,object:this.proxy}]:[{type:t,path:[n],value:a,oldValue:p,object:this.proxy}];return c(this,l),!0}deleteProperty(e,t){let n=e[t];if(delete e[t],n&&"object"==typeof n){const e=n[r];e&&(n=e.detach())}const s=[{type:o,path:[t],oldValue:n,object:this.proxy}];return c(this,s),!0}}class y extends f{constructor(e){super(e,a)}detach(){return this.parent=null,this.target}get(e,t){return i.hasOwnProperty(t)?i[t].bind(void 0,e,this):e[t]}}class u extends f{constructor(e){super(e,l)}detach(){return this.parent=null,this.target}}class b{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(e){if(e&&"object"==typeof e){if(e[r])return e;if(Array.isArray(e))return new y({target:e,ownKey:null,parent:null}).proxy;if(e instanceof Date||e instanceof Blob||e instanceof Error)throw new Error(`${e} found to be one of non-observable types`);return new u({target:e,ownKey:null,parent:null}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")}static isObservable(e){return!(!e||!e[r])}}Object.freeze(b);export{b as Observable};