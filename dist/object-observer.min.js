(()=>{"use strict";const e=this||window,t=Symbol("system-observer-key"),r={Date:!0,Blob:!0,Number:!0,String:!0,Boolean:!0,Error:!0,SyntaxError:!0,TypeError:!0,URIError:!0,Function:!0,Promise:!0,RegExp:!0};class o extends Array{constructor(e,o){super(e.length);let s,l=e.length;for(this[t]=o;l--;)(s=e[l])&&"object"==typeof s&&!r.hasOwnProperty(s.constructor.name)?this[l]=new n({target:s,ownKey:l,parent:o}).proxy:this[l]=s}revoke(){this[t].revoke()}observe(e){this[t].observe(e)}unobserve(){let e=this[t];e.unobserve.apply(e,arguments)}}class s{constructor(e,o){let s,l,a=Object.getOwnPropertyNames(e),i=a.length;for(this[t]=o;i--;)(l=e[s=a[i]])&&"object"==typeof l&&!r.hasOwnProperty(l.constructor.name)?this[s]=new n({target:l,ownKey:s,parent:o}).proxy:this[s]=l}revoke(){this[t].revoke()}observe(e){this[t].observe(e)}unobserve(){let e=this[t];e.unobserve.apply(e,arguments)}}class n{constructor(e){this.parent=e.parent,this.ownKey=e.ownKey;let t,r=e.target;Array.isArray(r)?(t=new o(r,this),this.revokable=Proxy.revocable(t,{deleteProperty:this.proxiedDelete.bind(this),set:this.proxiedSet.bind(this),get:this.proxiedArrayGet.bind(this)})):(t=new s(r,this),this.revokable=Proxy.revocable(t,{deleteProperty:this.proxiedDelete.bind(this),set:this.proxiedSet.bind(this)})),null===this.parent&&(this.isRevoked=!1,this.callbacks=[]),this.proxy=this.revokable.proxy,this.target=t}revoke(){let e,r,o,s=this.target,n=Object.keys(s),l=n.length;for(this.revokable.revoke();l--;)(r=s[e=n[l]])&&"object"==typeof r&&(o=r[t])&&(s[e]=o.revoke());return s}observe(e){if(this.isRevoked)throw new TypeError("revoked Observable MAY NOT be observed anymore");if("function"!=typeof e)throw new Error("observer (callback) parameter MUST be a function");this.callbacks.indexOf(e)<0?this.callbacks.push(e):console.info("observer (callback) may be bound to an observable only once")}unobserve(){if(this.isRevoked)throw new TypeError("revoked Observable MAY NOT be unobserved anymore");let e=arguments.length;if(e)for(;e--;){let t=this.callbacks.indexOf(arguments[e]);t>=0&&this.callbacks.splice(t,1)}else this.callbacks.splice(0)}getPath(){let e=[],t=[],r=0,o=0,s=this;for(;null!==s.ownKey;)e[r++]=s.ownKey,s=s.parent;for(;r--;)t[o++]=e[r];return t}getListeners(){let e=this;for(;e.parent;)e=e.parent;return e.callbacks}proxiedSet(e,o,s){let l,a,i,p=e[o];return s&&"object"==typeof s&&!r.hasOwnProperty(s.constructor.name)?e[o]=new n({target:s,ownKey:o,parent:this}).proxy:e[o]=s,p&&"object"==typeof p&&(l=p[t])&&(l.revoke(),p=l.target),(a=this.getListeners()).length&&((i=this.getPath()).push(o),n.callListeners(a,void 0!==p?[{type:"update",path:i,value:s,oldValue:p}]:[{type:"insert",path:i,value:s}])),!0}proxiedDelete(e,r){let o,s,l,a=e[r];return delete e[r]&&(a&&"object"==typeof a&&(o=a[t])&&(o.revoke(),a=o.target),(s=this.getListeners()).length&&((l=this.getPath()).push(r),n.callListeners(s,[{type:"delete",path:l,oldValue:a}])),!0)}proxiedArrayGet(e,o){const s={pop:function(e,r){let o,s,l;o=e.length-1,(s=e.pop())&&"object"==typeof s&&(l=s[t])&&(l.revoke(),s=l.target);let a=r.getObservers();if(a.length){let e=r.getPath();e.push(o),n.callListeners(a,[{type:"delete",path:e,oldValue:s}])}return s},push:function(e,t){let o,s,l,a=arguments.length-2,i=new Array(a),p=[],h=t.getObservers();s=e.length,h.length&&(l=t.getPath());for(let e,o=0;o<a;o++)(e=arguments[o+2])&&"object"==typeof e&&!r.hasOwnProperty(e.constructor.name)&&(e=new n({target:e,ownKey:s+o,parent:t}).proxy),i[o]=e;if(o=Reflect.apply(e.push,e,i),h.length){for(let t=s,r=e.length;t<r;t++){let r=l.slice(0);r.push(t),p[t-s]={type:"insert",path:r,value:e[t]}}n.callListeners(h,p)}return o},shift:function(e,r){let o,s,l=r.getObservers();(o=e.shift())&&"object"==typeof o&&(s=o[t])&&(s.revoke(),o=s.target);for(let r,o,s=0,n=e.length;s<n;s++)(r=e[s])&&"object"==typeof r&&((o=r[t])?o.ownKey=s:console.error("unexpectedly failed to resolve proxy -> observed"));if(l.length){let e=r.getPath();e.push(0),n.callListeners(l,[{type:"delete",path:e,oldValue:o}])}return o},unshift:function(e,o){let s,l,a,i=o.getObservers(),p=[];(s=Array.from(arguments)).splice(0,2),s.forEach((e,t)=>{e&&"object"==typeof e&&!r.hasOwnProperty(e.constructor.name)&&(s[t]=new n({target:e,ownKey:t,parent:o}).proxy)}),l=Reflect.apply(e.unshift,e,s);for(let r,o=0,s=e.length;o<s;o++)(r=e[o])&&"object"==typeof r&&((a=r[t])?a.ownKey=o:console.error("failed to resolve proxy -> observed"));if(i.length){let t,r=o.getPath();for(let o=0,n=s.length;o<n;o++)(t=r.slice(0)).push(o),p.push({type:"insert",path:t,value:e[o]});n.callListeners(i,p)}return l},reverse:function(e,r){let o,s=r.getObservers();e.reverse();for(let r,s=0,n=e.length;s<n;s++)(r=e[s])&&"object"==typeof r&&((o=r[t])?o.ownKey=s:console.error("failed to resolve proxy -> observed"));return s.length&&n.callListeners(s,[{type:"reverse",path:r.getPath()}]),r.proxy},sort:function(e,r,o){let s,l=r.getObservers();e.sort(o);for(let r,o=0,n=e.length;o<n;o++)(r=e[o])&&"object"==typeof r&&((s=r[t])?s.ownKey=o:console.error("failed to resolve proxy -> observed"));return l.length&&n.callListeners(l,[{type:"shuffle",path:r.getPath()}]),r.proxy},fill:function(e,o){let s,l,a,i,p,h,c,y=o.getObservers(),b=[],u=e.length;(s=Array.from(arguments)).splice(0,2),a=(l=s.length)<2?0:s[1]<0?u+s[1]:s[1],i=l<3?u:s[2]<0?u+s[2]:s[2],p=e.slice(0),Reflect.apply(e.fill,e,s),y.length&&(h=o.getPath());for(let s,l,y,u=a;u<i;u++)(s=e[u])&&"object"==typeof s&&!r.hasOwnProperty(s.constructor.name)&&(e[u]=new n({target:s,ownKey:u,parent:o}).proxy),p.hasOwnProperty(u)?((y=p[u])&&"object"==typeof y&&(l=y[t])&&(l.revoke(),y=l.target),(c=h.slice(0)).push(u),b.push({type:"update",path:c,value:e[u],oldValue:y})):((c=h.slice(0)).push(u),b.push({type:"insert",path:c,value:e[u]}));return y.length&&n.callListeners(y,b),o.proxy},splice:function(e,o){let s,l,a,i,p,h,c,y=o.getObservers(),b=[],u=e.length;(s=Array.from(arguments)).splice(0,2),c=s.length;for(let e,t=2;t<c;t++)(e=s[t])&&"object"==typeof e&&!r.hasOwnProperty(e.constructor.name)&&(s[t]=new n({target:e,ownKey:t,parent:o}).proxy);i=0===c?0:s[0]<0?u+s[0]:s[0],p=c<2?u-i:s[1],h=Math.max(c-2,0),l=Reflect.apply(e.splice,e,s),u=e.length;for(let r,o=0;o<u;o++)(r=e[o])&&"object"==typeof r&&((a=r[t])?a.ownKey=o:console.error("failed to resolve proxy -> target -> observed"));for(let e,r,o=0,s=l.length;o<s;o++)(e=l[o])&&"object"==typeof e&&(r=e[t])&&(r.revoke(),l[o]=r.target);if(y.length){let t,r,s=o.getPath();for(t=0;t<p;t++)(r=s.slice(0)).push(i+t),t<h?b.push({type:"update",path:r,value:e[i+t],oldValue:l[t]}):b.push({type:"delete",path:r,oldValue:l[t]});for(;t<h;t++)(r=s.slice(0)).push(i+t),b.push({type:"insert",path:r,value:e[i+t]});n.callListeners(y,b)}return l}};return s.hasOwnProperty(o)?s[o].bind(void 0,e,this):e[o]}static callListeners(e,t){let r=e.length;for(;r--;)try{e[r](t)}catch(e){console.error(e)}}}class l{static from(e){if(!(!e||"object"!=typeof e||r.hasOwnProperty(e.constructor.name)||"observe"in e||"unobserve"in e||"revoke"in e)){return new n({target:e,ownKey:null,parent:null}).proxy}if(!e||"object"!=typeof e)throw new Error("observable MAY ONLY be created from non-null object only");if("observe"in e||"unobserve"in e||"revoke"in e)throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: "observe", "unobserve", "revoke"');if(r.hasOwnProperty(e.constructor.name))throw new Error(e+" found to be one of non-observable object types: "+r)}}Object.freeze(l),Object.defineProperty(e,"Observable",{value:l})})();