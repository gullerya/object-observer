const e="insert",t="update",o="delete",r=Symbol("observable-meta-key"),n={path:1,pathsOf:1,pathsFrom:1},s=function(e,t){if("function"!=typeof e)throw new Error("observer parameter MUST be a function");const o=this[r].observers;if(o.some(t=>t[0]===e))console.info("observer may be bound to an observable only once");else{let r;r=t?function(e){const t={};void 0!==e.path&&("string"!=typeof e.path?console.error('"path" option, if/when provided, MUST be a non-empty string'):t.path=e.path),void 0!==e.pathsOf&&(e.path?console.error('"pathsOf" option MAY NOT be specified together with "path" option'):"string"!=typeof e.pathsOf?console.error('"pathsOf" option, if/when provided, MUST be a non-empty string'):t.pathsOf=e.pathsOf.split(".").filter(e=>e)),void 0!==e.pathsFrom&&(e.path||e.pathsOf?console.error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf"  option/s'):"string"!=typeof e.pathsFrom?console.error('"pathsFrom" option, if/when provided, MUST be a non-empty string'):t.pathsFrom=e.pathsFrom);const o=Object.keys(e).filter(e=>!n.hasOwnProperty(e));return o.length&&console.error(`'${o.join(", ")}' is/are not a valid option/s`),t}(t):{},o.push([e,r])}},a=function(){const e=this[r].observers;let t=e.length;if(t){let o=arguments.length;if(o)for(;o--;){let r=t;for(;r--;)e[r][0]===arguments[o]&&(e.splice(r,1),t--)}else e.splice(0)}},p=function(e,t){let o,n,p=e.length;for(n=Array.isArray(e)?Object.defineProperties(new Array(p),{[r]:{value:t},observe:{value:s},unobserve:{value:a}}):Object.defineProperties(e,{[r]:{value:t},observe:{value:s},unobserve:{value:a}});p--;)o=e[p],n[p]=o&&"object"==typeof o?i(o,p,t):o;return n},l=function(e,t){const o=Object.keys(e),n=Object.defineProperties({},{[r]:{value:t},observe:{value:s},unobserve:{value:a}});let p,l,c=o.length;for(;c--;)l=e[p=o[c]],n[p]=l&&"object"==typeof l?i(l,p,t):l;return n},c=function(e,t){let o,r,n,s,a,p,l,c,i,h;const f=t.length;for(;;){for(c=(o=e.observers).length;c--;)try{n=(r=o[c])[0],s=r[1],a=t,s.path?(p=s.path,a=t.filter(e=>e.path.join(".")===p)):s.pathsOf?a=t.filter(e=>e.path.length===s.pathsOf.length+1):s.pathsFrom&&(l=s.pathsFrom,a=t.filter(e=>e.path.join(".").startsWith(l))),a.length&&n(a)}catch(e){console.error(`failed to deliver changes to listener ${n}`,e)}let y;if(!e.parent)break;y=new Array(f);for(let o=0;o<f;o++)h=t[o],i=[e.ownKey],Array.prototype.push.apply(i,h.path),y[o]={type:h.type,path:i,value:h.value,oldValue:h.oldValue,object:h.object};t=y,e=e.parent}},i=function(e,t,o){return e&&"object"==typeof e?Array.isArray(e)?new d({target:e,ownKey:t,parent:o}).proxy:ArrayBuffer.isView(e)?new w({target:e,ownKey:t,parent:o}).proxy:e instanceof Date||e instanceof Blob||e instanceof Error?e:new g({target:e,ownKey:t,parent:o}).proxy:e},h=function(){const e=this[r],t=e.target;let o,n,s;for(t.reverse(),o=0,n=t.length;o<n;o++)if((s=t[o])&&"object"==typeof s){const e=s[r];e&&(e.ownKey=o)}const a=[{type:"reverse",path:[],object:e.proxy}];return c(e,a),e.proxy},f=function(e){const t=this[r],o=t.target;let n,s,a;for(o.sort(e),n=0,s=o.length;n<s;n++)if((a=o[n])&&"object"==typeof a){const e=a[r];e&&(e.ownKey=n)}const p=[{type:"shuffle",path:[],object:t.proxy}];return c(t,p),t.proxy},y=function(){const o=this[r],n=o.target,s=[],a=n.length,p=arguments.length,l=p<2?0:arguments[1]<0?a+arguments[1]:arguments[1],h=p<3?a:arguments[2]<0?a+arguments[2]:arguments[2],f=n.slice(0);let y;Reflect.apply(n.fill,n,arguments);for(let a,p,c=l;c<h;c++)a=n[c],n[c]=i(a,c,o),f.hasOwnProperty(c)?((p=f[c])&&"object"==typeof p&&(y=p[r])&&(p=y.detach()),s.push({type:t,path:[c],value:n[c],oldValue:p,object:o.proxy})):s.push({type:e,path:[c],value:n[c],object:o.proxy});return c(o,s),o.proxy},u={pop:function(){const e=this[r],t=e.target,n=t.length-1;let s=t.pop();if(s&&"object"==typeof s){const e=s[r];e&&(s=e.detach())}const a=[{type:o,path:[n],oldValue:s,object:e.proxy}];return c(e,a),s},push:function(){const t=this[r],o=t.target,n=arguments.length,s=new Array(n),a=o.length;for(let e=0;e<n;e++)s[e]=i(arguments[e],a+e,t);const p=Reflect.apply(o.push,o,s),l=[];for(let r=a,n=o.length;r<n;r++)l[r-a]={type:e,path:[r],value:o[r],object:t.proxy};return c(t,l),p},shift:function(){const e=this[r],t=e.target;let n,s,a,p,l;for((n=t.shift())&&"object"==typeof n&&(l=n[r])&&(n=l.detach()),s=0,a=t.length;s<a;s++)(p=t[s])&&"object"==typeof p&&(l=p[r])&&(l.ownKey=s);const i=[{type:o,path:[0],oldValue:n,object:e.proxy}];return c(e,i),n},unshift:function(){const t=this[r],o=t.target,n=arguments.length,s=new Array(n);for(let e=0;e<n;e++)s[e]=i(arguments[e],e,t);const a=Reflect.apply(o.unshift,o,s);for(let e,t=0,n=o.length;t<n;t++)if((e=o[t])&&"object"==typeof e){const o=e[r];o&&(o.ownKey=t)}const p=s.length,l=new Array(p);for(let r=0;r<p;r++)l[r]={type:e,path:[r],value:o[r],object:t.proxy};return c(t,l),a},reverse:h,sort:f,fill:y,splice:function(){const n=this[r],s=n.target,a=arguments.length,p=new Array(a),l=s.length;for(let e=0;e<a;e++)p[e]=i(arguments[e],e,n);const h=0===a?0:p[0]<0?l+p[0]:p[0],f=a<2?l-h:p[1],y=Math.max(a-2,0),u=Reflect.apply(s.splice,s,p),b=s.length;let v,g,d,w;for(let e,t=0;t<b;t++)(e=s[t])&&"object"==typeof e&&(v=e[r])&&(v.ownKey=t);for(g=0,d=u.length;g<d;g++)(w=u[g])&&"object"==typeof w&&(v=w[r])&&(u[g]=v.detach());const j=[];let x;for(x=0;x<f;x++)x<y?j.push({type:t,path:[h+x],value:s[h+x],oldValue:u[x],object:n.proxy}):j.push({type:o,path:[h+x],oldValue:u[x],object:n.proxy});for(;x<y;x++)j.push({type:e,path:[h+x],value:s[h+x],object:n.proxy});return c(n,j),u}},b={reverse:h,sort:f,fill:y,set:function(){}};class v{constructor(e,t){const o=e.target,r=e.parent,n=e.ownKey;r&&void 0!==n?(this.parent=r,this.ownKey=n):(this.parent=null,this.ownKey=null);const s=t(o,this);this.observers=[],this.revokable=Proxy.revocable(s,this),this.proxy=this.revokable.proxy,this.target=s}detach(){return this.parent=null,this.target}set(o,n,s){let a=o[n];if(s!==a){const p=i(s,n,this);if(o[n]=p,a&&"object"==typeof a){const e=a[r];e&&(a=e.detach())}const l=void 0===a?[{type:e,path:[n],value:p,object:this.proxy}]:[{type:t,path:[n],value:p,oldValue:a,object:this.proxy}];c(this,l)}return!0}deleteProperty(e,t){let n=e[t];if(delete e[t],n&&"object"==typeof n){const e=n[r];e&&(n=e.detach())}const s=[{type:o,path:[t],oldValue:n,object:this.proxy}];return c(this,s),!0}}class g extends v{constructor(e){super(e,l)}}class d extends v{constructor(e){super(e,p)}get(e,t){return u.hasOwnProperty(t)?u[t]:e[t]}}class w extends v{constructor(e){super(e,p)}get(e,t){return b.hasOwnProperty(t)?b[t]:e[t]}}class j{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(e){if(e&&"object"==typeof e){if(e[r])return e;if(Array.isArray(e))return new d({target:e,ownKey:null,parent:null}).proxy;if(ArrayBuffer.isView(e))return new w({target:e,ownKey:null,parent:null}).proxy;if(e instanceof Date||e instanceof Blob||e instanceof Error)throw new Error(`${e} found to be one of non-observable types`);return new g({target:e,ownKey:null,parent:null}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")}static isObservable(e){return!(!e||!e[r])}}Object.freeze(j),exports.Observable=j;