const e=Symbol("system-observer-key"),t={Date:!0,Blob:!0,Number:!0,String:!0,Boolean:!0,Error:!0,SyntaxError:!0,TypeError:!0,URIError:!0,Function:!0,Promise:!0,RegExp:!0},r=function(r,o,n){let a,s=r.length;for(o[e]=n;s--;)(a=r[s])&&"object"==typeof a&&!t.hasOwnProperty(a.constructor.name)?o[s]=Array.isArray(a)?new c({target:a,ownKey:s,parent:n}).proxy:new f({target:a,ownKey:s,parent:n}).proxy:o[s]=a},o=function(r,o,n){let a,s,l=Object.keys(r),p=l.length;for(o[e]=n;p--;)(s=r[a=l[p]])&&"object"==typeof s&&!t.hasOwnProperty(s.constructor.name)?o[a]=Array.isArray(s)?new c({target:s,ownKey:a,parent:n}).proxy:new f({target:s,ownKey:a,parent:n}).proxy:o[a]=s},n=function(e,t){let r=e.length;for(;r--;)try{e[r](t)}catch(t){console.error("failed to deliver changes to listener"+e[r],t)}},a="insert",s="update",l="delete",p="reverse",i="shuffle";class h extends Array{revoke(){this[e].revoke()}observe(t){let r=this[e],o=r.callbacks;if(r.isRevoked)throw new TypeError("revoked Observable MAY NOT be observed anymore");if("function"!=typeof t)throw new Error("observer (callback) parameter MUST be a function");o.indexOf(t)<0?o.push(t):console.info("observer (callback) may be bound to an observable only once")}unobserve(){let t,r,o=this[e],n=o.callbacks;if(o.isRevoked)throw new TypeError("revoked Observable MAY NOT be unobserved anymore");if(t=arguments.length)for(;t--;)(r=n.indexOf(arguments[t]))>=0&&n.splice(r,1);else n.splice(0)}}class y{revoke(){this[e].revoke()}observe(t){let r=this[e],o=r.callbacks;if(r.isRevoked)throw new TypeError("revoked Observable MAY NOT be observed anymore");if("function"!=typeof t)throw new Error("observer (callback) parameter MUST be a function");o.indexOf(t)<0?o.push(t):console.info("observer (callback) may be bound to an observable only once")}unobserve(){let t,r,o=this[e],n=o.callbacks;if(o.isRevoked)throw new TypeError("revoked Observable MAY NOT be unobserved anymore");if(t=arguments.length)for(;t--;)(r=n.indexOf(arguments[t]))>=0&&n.splice(r,1);else n.splice(0)}}class c{constructor(e){let t,o=e.target;null===e.parent?(this.isRevoked=!1,this.callbacks=[],t=new h(o.length)):(this.parent=e.parent,this.ownKey=e.ownKey,t=new Array(o.length)),r(o,t,this),this.revokable=Proxy.revocable(t,this),this.proxy=this.revokable.proxy,this.target=t}revoke(){this.revokable.revoke();let t,r=this.target,o=r.length;for(;o--;)if((t=r[o])&&"object"==typeof t){let n=t[e];n&&(r[o]=n.revoke())}return r}getPath(){let e,t=[],r=0,o=0,n=this;for(;n.parent;)t[r++]=n.ownKey,n=n.parent;for(e=new Array(r);r--;)e[o++]=t[r];return e}getListeners(){let e=this;for(;e.parent;)e=e.parent;return e.callbacks}set(r,o,l){let p,i,h,y=r[o];if(l&&"object"==typeof l&&!t.hasOwnProperty(l.constructor.name)?r[o]=Array.isArray(l)?new c({target:l,ownKey:o,parent:this}).proxy:new f({target:l,ownKey:o,parent:this}).proxy:r[o]=l,y&&"object"==typeof y){let t=y[e];t&&(y=t.revoke())}return(p=this.getListeners()).length&&((i=this.getPath()).push(o),n(p,h=void 0===y?[{type:a,path:i,value:l}]:[{type:s,path:i,value:l,oldValue:y}])),!0}deleteProperty(t,r){let o,a,s,p=t[r];if(delete t[r]){if(p&&"object"==typeof p){let t=p[e];t&&(p=t.revoke())}return(o=this.getListeners()).length&&((a=this.getPath()).push(r),n(o,s=[{type:l,path:a,oldValue:p}])),!0}return!1}get(r,o){const h={pop:function(t,r){let o,a;if(o=t.length-1,(a=t.pop())&&"object"==typeof a){let t=a[e];t&&(a=t.revoke())}let s=r.getListeners();if(s.length){let e=r.getPath();e.push(o),n(s,[{type:l,path:e,oldValue:a}])}return a},push:function(e,r){let o,s,l,p,i,h,y=arguments.length-2,u=new Array(y),b=r.getListeners();for(i=e.length,b.length&&(h=r.getPath()),o=0;o<y;o++)(s=arguments[o+2])&&"object"==typeof s&&!t.hasOwnProperty(s.constructor.name)&&(s=Array.isArray(s)?new c({target:s,ownKey:i+o,parent:r}).proxy:new f({target:s,ownKey:i+o,parent:r}).proxy),u[o]=s;if(l=Reflect.apply(e.push,e,u),b.length){for(p=[],o=i,y=e.length;o<y;o++){let t=h.slice(0);t.push(o),p[o-i]={type:a,path:t,value:e[o]}}n(b,p)}return l},shift:function(t,r){let o,a,s,p,i,h,y;if((o=t.shift())&&"object"==typeof o){let t=o[e];t&&(o=t.revoke())}for(a=0,s=t.length;a<s;a++)if((p=t[a])&&"object"==typeof p){let t=p[e];t&&(t.ownKey=a)}return(i=r.getListeners()).length&&((h=r.getPath()).push(0),n(i,y=[{type:l,path:h,oldValue:o}])),o},unshift:function(r,o){let s,l,p,i=o.getListeners();(s=Array.from(arguments)).splice(0,2),s.forEach((e,r)=>{e&&"object"==typeof e&&!t.hasOwnProperty(e.constructor.name)&&(s[r]=Array.isArray(e)?new c({target:e,ownKey:r,parent:o}).proxy:new f({target:e,ownKey:r,parent:o}).proxy)}),l=Reflect.apply(r.unshift,r,s);for(let t,o=0,n=r.length;o<n;o++)if((t=r[o])&&"object"==typeof t){let r=t[e];r&&(r.ownKey=o)}if(i.length){let e,t=o.getPath(),l=s.length;p=new Array(l);for(let o=0;o<l;o++)(e=t.slice(0)).push(o),p[o]={type:a,path:e,value:r[o]};n(i,p)}return l},reverse:function(t,r){let o,a,s,l,i;for(t.reverse(),o=0,a=t.length;o<a;o++)if((s=t[o])&&"object"==typeof s){let t=s[e];t&&(t.ownKey=o)}return(l=r.getListeners()).length&&(i=[{type:p,path:r.getPath()}],n(l,i)),r.proxy},sort:function(t,r,o){let a,s,l,p,h;for(t.sort(o),a=0,s=t.length;a<s;a++)if((l=t[a])&&"object"==typeof l){let t=l[e];t&&(t.ownKey=a)}return(p=r.getListeners()).length&&(h=[{type:i,path:r.getPath()}],n(p,h)),r.proxy},fill:function(r,o){let l,p,i,h,y,u,b,g=o.getListeners(),w=[],v=r.length;(l=Array.from(arguments)).splice(0,2),i=(p=l.length)<2?0:l[1]<0?v+l[1]:l[1],h=p<3?v:l[2]<0?v+l[2]:l[2],y=r.slice(0),Reflect.apply(r.fill,r,l),g.length&&(u=o.getPath());for(let n,l,p=i;p<h;p++)if((n=r[p])&&"object"==typeof n&&!t.hasOwnProperty(n.constructor.name)&&(r[p]=Array.isArray(n)?new c({target:n,ownKey:p,parent:o}).proxy:new f({target:n,ownKey:p,parent:o}).proxy),y.hasOwnProperty(p)){if((l=y[p])&&"object"==typeof l){let t=l[e];t&&(l=t.revoke())}(b=u.slice(0)).push(p),w.push({type:s,path:b,value:r[p],oldValue:l})}else(b=u.slice(0)).push(p),w.push({type:a,path:b,value:r[p]});return g.length&&n(g,w),o.proxy},splice:function(r,o){let p,i,h,y,u,b,g,w,v,k,d=o.getListeners(),x=[],A=r.length;(p=Array.from(arguments)).splice(0,2),g=p.length;for(let e,r=2;r<g;r++)(e=p[r])&&"object"==typeof e&&!t.hasOwnProperty(e.constructor.name)&&(p[r]=Array.isArray(e)?new c({target:e,ownKey:r,parent:o}).proxy:new f({target:e,ownKey:r,parent:o}).proxy);y=0===g?0:p[0]<0?A+p[0]:p[0],u=g<2?A-y:p[1],b=Math.max(g-2,0),i=Reflect.apply(r.splice,r,p),A=r.length;for(let t,o=0;o<A;o++)(t=r[o])&&"object"==typeof t&&(h=t[e])&&(h.ownKey=o);for(w=0,v=i.length;w<v;w++)(k=i[w])&&"object"==typeof k&&(h=k[e])&&(i[w]=h.revoke());if(d.length){let e,t,p=o.getPath();for(e=0;e<u;e++)(t=p.slice(0)).push(y+e),e<b?x.push({type:s,path:t,value:r[y+e],oldValue:i[e]}):x.push({type:l,path:t,oldValue:i[e]});for(;e<b;e++)(t=p.slice(0)).push(y+e),x.push({type:a,path:t,value:r[y+e]});n(d,x)}return i}};return h.hasOwnProperty(o)?h[o].bind(void 0,r,this):r[o]}}class f{constructor(e){let t,r=e.target;null===e.parent?(this.isRevoked=!1,this.callbacks=[],t=new y):(this.parent=e.parent,this.ownKey=e.ownKey,t={}),o(r,t,this),this.revokable=Proxy.revocable(t,this),this.proxy=this.revokable.proxy,this.target=t}revoke(){this.revokable.revoke();let t,r,o=this.target,n=Object.keys(o),a=n.length;for(;a--;)if((r=o[t=n[a]])&&"object"==typeof r){let n=r[e];n&&(o[t]=n.revoke())}return o}getPath(){let e,t=[],r=0,o=0,n=this;for(;n.parent;)t[r++]=n.ownKey,n=n.parent;for(e=new Array(r);r--;)e[o++]=t[r];return e}getListeners(){let e=this;for(;e.parent;)e=e.parent;return e.callbacks}set(r,o,l){let p,i,h,y=r[o];if(l&&"object"==typeof l&&!t.hasOwnProperty(l.constructor.name)?r[o]=Array.isArray(l)?new c({target:l,ownKey:o,parent:this}).proxy:new f({target:l,ownKey:o,parent:this}).proxy:r[o]=l,y&&"object"==typeof y){let t=y[e];t&&(y=t.revoke())}return(p=this.getListeners()).length&&((i=this.getPath()).push(o),n(p,h=void 0===y?[{type:a,path:i,value:l}]:[{type:s,path:i,value:l,oldValue:y}])),!0}deleteProperty(t,r){let o,a,s,p=t[r];if(delete t[r]){if(p&&"object"==typeof p){let t=p[e];t&&(p=t.revoke())}return(o=this.getListeners()).length&&((a=this.getPath()).push(r),n(o,s=[{type:l,path:a,oldValue:p}])),!0}return!1}}class u{static from(e){if(!(!e||"object"!=typeof e||t.hasOwnProperty(e.constructor.name)||"observe"in e||"unobserve"in e||"revoke"in e)){return(Array.isArray(e)?new c({target:e,ownKey:null,parent:null}):new f({target:e,ownKey:null,parent:null})).proxy}if(!e||"object"!=typeof e)throw new Error("observable MAY ONLY be created from non-null object only");if("observe"in e||"unobserve"in e||"revoke"in e)throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: "observe", "unobserve", "revoke"');if(t.hasOwnProperty(e.constructor.name))throw new Error(e+" found to be one of non-observable object types: "+t)}}Object.freeze(u),module.exports=u;