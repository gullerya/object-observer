const e=new Map,t={Date:!0,Blob:!0,Number:!0,String:!0,Boolean:!0,Error:!0,SyntaxError:!0,TypeError:!0,URIError:!0,Function:!0,Promise:!0,RegExp:!0};class r extends Array{constructor(e,r){super(e.length);let o,n=e.length;for(;n--;)(o=e[n])&&"object"==typeof o&&!t.hasOwnProperty(o.constructor.name)?this[n]=new s({target:o,ownKey:n,parent:r}).proxy:this[n]=o}revoke(){e.get(this).revoke()}observe(t){e.get(this).observe(t)}unobserve(){let t=e.get(this);t.unobserve.apply(t,arguments)}}class o{constructor(e,r){let o,n,l=Object.getOwnPropertyNames(e),a=l.length;for(;a--;)(n=e[o=l[a]])&&"object"==typeof n&&!t.hasOwnProperty(n.constructor.name)?this[o]=new s({target:n,ownKey:o,parent:r}).proxy:this[o]=n}revoke(){e.get(this).revoke()}observe(t){e.get(this).observe(t)}unobserve(){let t=e.get(this);t.unobserve.apply(t,arguments)}}class s{constructor(t){this.parent=t.parent,this.ownKey=t.ownKey;let s,n=t.target;Array.isArray(n)?(s=new r(n,this),this.revokable=Proxy.revocable(s,{deleteProperty:this.proxiedDelete.bind(this),set:this.proxiedSet.bind(this),get:this.proxiedArrayGet.bind(this)})):(s=new o(n,this),this.revokable=Proxy.revocable(s,{deleteProperty:this.proxiedDelete.bind(this),set:this.proxiedSet.bind(this)})),null===this.parent&&(this.isRevoked=!1,this.callbacks=[]),this.proxy=this.revokable.proxy,this.target=s,e.set(this.proxy,this)}revoke(){let t,r,o,s=this.target,n=Object.keys(s),l=n.length;for(this.revokable.revoke();l--;)(r=s[t=n[l]])&&"object"==typeof r&&(o=e.get(r))&&(s[t]=o.revoke());return e.delete(this.proxy),s}observe(e){if(this.isRevoked)throw new TypeError("revoked Observable MAY NOT be observed anymore");if("function"!=typeof e)throw new Error("observer (callback) parameter MUST be a function");this.callbacks.indexOf(e)<0?this.callbacks.push(e):console.info("observer (callback) may be bound to an observable only once")}unobserve(){if(this.isRevoked)throw new TypeError("revoked Observable MAY NOT be unobserved anymore");let e=arguments.length;if(e)for(;e--;){let t=this.callbacks.indexOf(arguments[e]);t>=0&&this.callbacks.splice(t,1)}else this.callbacks.splice(0)}getPath(){let e=[],t=[],r=0,o=0,s=this;for(;null!==s.ownKey;)e[r++]=s.ownKey,s=s.parent;for(;r--;)t[o++]=e[r];return t}getListeners(){let e=this;for(;e.parent;)e=e.parent;return e.callbacks}static callListeners(e,t){let r=e.length;for(;r--;)try{e[r](t)}catch(e){console.error(e)}}proxiedDelete(t,r){let o=t[r];if(delete t[r]){if(o&&"object"==typeof o){let t=e.get(o);t&&(t.revoke(),o=t.target)}let t=this.getListeners();if(t.length){let e=this.getPath();e.push(r),s.callListeners(t,[{type:"delete",path:e,oldValue:o}])}return!0}return!1}proxiedSet(r,o,n){let l=r[o];if(n&&"object"==typeof n&&!t.hasOwnProperty(n.constructor.name)?r[o]=new s({target:n,ownKey:o,parent:this}).proxy:r[o]=n,l&&"object"==typeof l){let t=e.get(l);t&&(t.revoke(),l=t.target)}let a=this.getListeners();if(a.length){let e=this.getPath();e.push(o),s.callListeners(a,void 0!==l?[{type:"update",path:e,value:n,oldValue:l}]:[{type:"insert",path:e,value:n}])}return!0}proxiedArrayGet(r,o){const n={pop:function(t,r){let o,n,l;o=t.length-1,(n=t.pop())&&"object"==typeof n&&(l=e.get(n))&&(l.revoke(),n=l.target);let a=r.getListeners();if(a.length){let e=r.getPath();e.push(o),s.callListeners(a,[{type:"delete",path:e,oldValue:n}])}return n},push:function(e,r){let o,n,l,a=arguments.length-2,i=new Array(a),p=[],h=r.getListeners();n=e.length,h.length&&(l=r.getPath());for(let e,o=0;o<a;o++)(e=arguments[o+2])&&"object"==typeof e&&!t.hasOwnProperty(e.constructor.name)&&(e=new s({target:e,ownKey:n+o,parent:r}).proxy),i[o]=e;if(o=Reflect.apply(e.push,e,i),h.length){for(let t=n,r=e.length;t<r;t++){let r=l.slice(0);r.push(t),p[t-n]={type:"insert",path:r,value:e[t]}}s.callListeners(h,p)}return o},shift:function(t,r){let o,n,l=r.getListeners();(o=t.shift())&&"object"==typeof o&&(n=e.get(o))&&(n.revoke(),o=n.target);for(let r,o,s=0,n=t.length;s<n;s++)(r=t[s])&&"object"==typeof r&&((o=e.get(r))?o.ownKey=s:console.error("unexpectedly failed to resolve proxy -> observed"));if(l.length){let e=r.getPath();e.push(0),s.callListeners(l,[{type:"delete",path:e,oldValue:o}])}return o},unshift:function(r,o){let n,l,a,i=o.getListeners(),p=[];(n=Array.from(arguments)).splice(0,2),n.forEach((e,r)=>{e&&"object"==typeof e&&!t.hasOwnProperty(e.constructor.name)&&(n[r]=new s({target:e,ownKey:r,parent:o}).proxy)}),l=Reflect.apply(r.unshift,r,n);for(let t,o=0,s=r.length;o<s;o++)(t=r[o])&&"object"==typeof t&&((a=e.get(t))?a.ownKey=o:console.error("failed to resolve proxy -> observed"));if(i.length){let e,t=o.getPath();for(let o=0,s=n.length;o<s;o++)(e=t.slice(0)).push(o),p.push({type:"insert",path:e,value:r[o]});s.callListeners(i,p)}return l},reverse:function(t,r){let o,n=r.getListeners();t.reverse();for(let r,s=0,n=t.length;s<n;s++)(r=t[s])&&"object"==typeof r&&((o=e.get(r))?o.ownKey=s:console.error("failed to resolve proxy -> observed"));return n.length&&s.callListeners(n,[{type:"reverse",path:r.getPath()}]),r.proxy},sort:function(t,r,o){let n,l=r.getListeners();t.sort(o);for(let r,o=0,s=t.length;o<s;o++)(r=t[o])&&"object"==typeof r&&((n=e.get(r))?n.ownKey=o:console.error("failed to resolve proxy -> observed"));return l.length&&s.callListeners(l,[{type:"shuffle",path:r.getPath()}]),r.proxy},fill:function(r,o){let n,l,a,i,p,h,c,y=o.getListeners(),f=[],u=r.length;(n=Array.from(arguments)).splice(0,2),a=(l=n.length)<2?0:n[1]<0?u+n[1]:n[1],i=l<3?u:n[2]<0?u+n[2]:n[2],p=r.slice(0),Reflect.apply(r.fill,r,n),y.length&&(h=o.getPath());for(let n,l,y,u=a;u<i;u++)(n=r[u])&&"object"==typeof n&&!t.hasOwnProperty(n.constructor.name)&&(r[u]=new s({target:n,ownKey:u,parent:o}).proxy),p.hasOwnProperty(u)?((y=p[u])&&"object"==typeof y&&(l=e.get(y))&&(l.revoke(),y=l.target),(c=h.slice(0)).push(u),f.push({type:"update",path:c,value:r[u],oldValue:y})):((c=h.slice(0)).push(u),f.push({type:"insert",path:c,value:r[u]}));return y.length&&s.callListeners(y,f),o.proxy},splice:function(r,o){let n,l,a,i,p,h,c,y=o.getListeners(),f=[],u=r.length;(n=Array.from(arguments)).splice(0,2),c=n.length;for(let e,r=2;r<c;r++)(e=n[r])&&"object"==typeof e&&!t.hasOwnProperty(e.constructor.name)&&(n[r]=new s({target:e,ownKey:r,parent:o}).proxy);i=0===c?0:n[0]<0?u+n[0]:n[0],p=c<2?u-i:n[1],h=Math.max(c-2,0),l=Reflect.apply(r.splice,r,n),u=r.length;for(let t,o=0;o<u;o++)(t=r[o])&&"object"==typeof t&&((a=e.get(t))?a.ownKey=o:console.error("failed to resolve proxy -> target -> observed"));for(let t,r,o=0,s=l.length;o<s;o++)(t=l[o])&&"object"==typeof t&&(r=e.get(t))&&(r.revoke(),l[o]=r.target);if(y.length){let e,t,n=o.getPath();for(e=0;e<p;e++)(t=n.slice(0)).push(i+e),e<h?f.push({type:"update",path:t,value:r[i+e],oldValue:l[e]}):f.push({type:"delete",path:t,oldValue:l[e]});for(;e<h;e++)(t=n.slice(0)).push(i+e),f.push({type:"insert",path:t,value:r[i+e]});s.callListeners(y,f)}return l}};return n.hasOwnProperty(o)?n[o].bind(void 0,r,this):r[o]}}class n{static from(e){if(!(!e||"object"!=typeof e||t.hasOwnProperty(e.constructor.name)||"observe"in e||"unobserve"in e||"revoke"in e)){return new s({target:e,ownKey:null,parent:null}).proxy}if(!e||"object"!=typeof e)throw new Error("observable MAY ONLY be created from non-null object only");if("observe"in e||"unobserve"in e||"revoke"in e)throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: "observe", "unobserve", "revoke"');if(t.hasOwnProperty(e.constructor.name))throw new Error(e+" found to be one of non-observable object types: "+t)}}Object.freeze(n),module.exports=n;