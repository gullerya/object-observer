const e=Symbol("system-observer-key"),t={Date:!0,Blob:!0,Number:!0,String:!0,Boolean:!0,Error:!0,SyntaxError:!0,TypeError:!0,URIError:!0,Function:!0,Promise:!0,RegExp:!0};class r extends Array{constructor(r,o){super(r.length);let n,l=r.length;for(this[e]=o;l--;)(n=r[l])&&"object"==typeof n&&!t.hasOwnProperty(n.constructor.name)?this[l]=new s({target:n,ownKey:l,parent:o}).proxy:this[l]=n}revoke(){this[e].revoke()}observe(t){this[e].observe(t)}unobserve(){let t=this[e];t.unobserve.apply(t,arguments)}}class o{constructor(r,o){let n,l,a=Object.getOwnPropertyNames(r),i=a.length;for(this[e]=o;i--;)(l=r[n=a[i]])&&"object"==typeof l&&!t.hasOwnProperty(l.constructor.name)?this[n]=new s({target:l,ownKey:n,parent:o}).proxy:this[n]=l}revoke(){this[e].revoke()}observe(t){this[e].observe(t)}unobserve(){let t=this[e];t.unobserve.apply(t,arguments)}}class s{constructor(e){this.parent=e.parent,this.ownKey=e.ownKey;let t,s=e.target;Array.isArray(s)?(t=new r(s,this),this.revokable=Proxy.revocable(t,{deleteProperty:this.proxiedDelete.bind(this),set:this.proxiedSet.bind(this),get:this.proxiedArrayGet.bind(this)})):(t=new o(s,this),this.revokable=Proxy.revocable(t,{deleteProperty:this.proxiedDelete.bind(this),set:this.proxiedSet.bind(this)})),null===this.parent&&(this.isRevoked=!1,this.callbacks=[]),this.proxy=this.revokable.proxy,this.target=t}revoke(){let t,r,o,s=this.target,n=Object.keys(s),l=n.length;for(this.revokable.revoke();l--;)(r=s[t=n[l]])&&"object"==typeof r&&(o=r[e])&&(s[t]=o.revoke());return s}observe(e){if(this.isRevoked)throw new TypeError("revoked Observable MAY NOT be observed anymore");if("function"!=typeof e)throw new Error("observer (callback) parameter MUST be a function");this.callbacks.indexOf(e)<0?this.callbacks.push(e):console.info("observer (callback) may be bound to an observable only once")}unobserve(){if(this.isRevoked)throw new TypeError("revoked Observable MAY NOT be unobserved anymore");let e=arguments.length;if(e)for(;e--;){let t=this.callbacks.indexOf(arguments[e]);t>=0&&this.callbacks.splice(t,1)}else this.callbacks.splice(0)}getPath(){let e=[],t=[],r=0,o=0,s=this;for(;null!==s.ownKey;)e[r++]=s.ownKey,s=s.parent;for(;r--;)t[o++]=e[r];return t}getListeners(){let e=this;for(;e.parent;)e=e.parent;return e.callbacks}proxiedSet(r,o,n){let l,a,i,p=r[o];return n&&"object"==typeof n&&!t.hasOwnProperty(n.constructor.name)?r[o]=new s({target:n,ownKey:o,parent:this}).proxy:r[o]=n,p&&"object"==typeof p&&(l=p[e])&&(l.revoke(),p=l.target),(a=this.getListeners()).length&&((i=this.getPath()).push(o),s.callListeners(a,void 0!==p?[{type:"update",path:i,value:n,oldValue:p}]:[{type:"insert",path:i,value:n}])),!0}proxiedDelete(t,r){let o,n,l,a=t[r];return delete t[r]&&(a&&"object"==typeof a&&(o=a[e])&&(o.revoke(),a=o.target),(n=this.getListeners()).length&&((l=this.getPath()).push(r),s.callListeners(n,[{type:"delete",path:l,oldValue:a}])),!0)}proxiedArrayGet(r,o){const n={pop:function(t,r){let o,n,l;o=t.length-1,(n=t.pop())&&"object"==typeof n&&(l=n[e])&&(l.revoke(),n=l.target);let a=r.getListeners();if(a.length){let e=r.getPath();e.push(o),s.callListeners(a,[{type:"delete",path:e,oldValue:n}])}return n},push:function(e,r){let o,n,l,a=arguments.length-2,i=new Array(a),p=[],h=r.getListeners();n=e.length,h.length&&(l=r.getPath());for(let e,o=0;o<a;o++)(e=arguments[o+2])&&"object"==typeof e&&!t.hasOwnProperty(e.constructor.name)&&(e=new s({target:e,ownKey:n+o,parent:r}).proxy),i[o]=e;if(o=Reflect.apply(e.push,e,i),h.length){for(let t=n,r=e.length;t<r;t++){let r=l.slice(0);r.push(t),p[t-n]={type:"insert",path:r,value:e[t]}}s.callListeners(h,p)}return o},shift:function(t,r){let o,n,l=r.getListeners();(o=t.shift())&&"object"==typeof o&&(n=o[e])&&(n.revoke(),o=n.target);for(let r,o,s=0,n=t.length;s<n;s++)(r=t[s])&&"object"==typeof r&&((o=r[e])?o.ownKey=s:console.error("unexpectedly failed to resolve proxy -> observed"));if(l.length){let e=r.getPath();e.push(0),s.callListeners(l,[{type:"delete",path:e,oldValue:o}])}return o},unshift:function(r,o){let n,l,a,i=o.getListeners(),p=[];(n=Array.from(arguments)).splice(0,2),n.forEach((e,r)=>{e&&"object"==typeof e&&!t.hasOwnProperty(e.constructor.name)&&(n[r]=new s({target:e,ownKey:r,parent:o}).proxy)}),l=Reflect.apply(r.unshift,r,n);for(let t,o=0,s=r.length;o<s;o++)(t=r[o])&&"object"==typeof t&&((a=t[e])?a.ownKey=o:console.error("failed to resolve proxy -> observed"));if(i.length){let e,t=o.getPath();for(let o=0,s=n.length;o<s;o++)(e=t.slice(0)).push(o),p.push({type:"insert",path:e,value:r[o]});s.callListeners(i,p)}return l},reverse:function(t,r){let o,n=r.getListeners();t.reverse();for(let r,s=0,n=t.length;s<n;s++)(r=t[s])&&"object"==typeof r&&((o=r[e])?o.ownKey=s:console.error("failed to resolve proxy -> observed"));return n.length&&s.callListeners(n,[{type:"reverse",path:r.getPath()}]),r.proxy},sort:function(t,r,o){let n,l=r.getListeners();t.sort(o);for(let r,o=0,s=t.length;o<s;o++)(r=t[o])&&"object"==typeof r&&((n=r[e])?n.ownKey=o:console.error("failed to resolve proxy -> observed"));return l.length&&s.callListeners(l,[{type:"shuffle",path:r.getPath()}]),r.proxy},fill:function(r,o){let n,l,a,i,p,h,c,y=o.getListeners(),f=[],u=r.length;(n=Array.from(arguments)).splice(0,2),a=(l=n.length)<2?0:n[1]<0?u+n[1]:n[1],i=l<3?u:n[2]<0?u+n[2]:n[2],p=r.slice(0),Reflect.apply(r.fill,r,n),y.length&&(h=o.getPath());for(let n,l,y,u=a;u<i;u++)(n=r[u])&&"object"==typeof n&&!t.hasOwnProperty(n.constructor.name)&&(r[u]=new s({target:n,ownKey:u,parent:o}).proxy),p.hasOwnProperty(u)?((y=p[u])&&"object"==typeof y&&(l=y[e])&&(l.revoke(),y=l.target),(c=h.slice(0)).push(u),f.push({type:"update",path:c,value:r[u],oldValue:y})):((c=h.slice(0)).push(u),f.push({type:"insert",path:c,value:r[u]}));return y.length&&s.callListeners(y,f),o.proxy},splice:function(r,o){let n,l,a,i,p,h,c,y=o.getListeners(),f=[],u=r.length;(n=Array.from(arguments)).splice(0,2),c=n.length;for(let e,r=2;r<c;r++)(e=n[r])&&"object"==typeof e&&!t.hasOwnProperty(e.constructor.name)&&(n[r]=new s({target:e,ownKey:r,parent:o}).proxy);i=0===c?0:n[0]<0?u+n[0]:n[0],p=c<2?u-i:n[1],h=Math.max(c-2,0),l=Reflect.apply(r.splice,r,n),u=r.length;for(let t,o=0;o<u;o++)(t=r[o])&&"object"==typeof t&&((a=t[e])?a.ownKey=o:console.error("failed to resolve proxy -> target -> observed"));for(let t,r,o=0,s=l.length;o<s;o++)(t=l[o])&&"object"==typeof t&&(r=t[e])&&(r.revoke(),l[o]=r.target);if(y.length){let e,t,n=o.getPath();for(e=0;e<p;e++)(t=n.slice(0)).push(i+e),e<h?f.push({type:"update",path:t,value:r[i+e],oldValue:l[e]}):f.push({type:"delete",path:t,oldValue:l[e]});for(;e<h;e++)(t=n.slice(0)).push(i+e),f.push({type:"insert",path:t,value:r[i+e]});s.callListeners(y,f)}return l}};return n.hasOwnProperty(o)?n[o].bind(void 0,r,this):r[o]}static callListeners(e,t){let r=e.length;for(;r--;)try{e[r](t)}catch(e){console.error(e)}}}class n{static from(e){if(!(!e||"object"!=typeof e||t.hasOwnProperty(e.constructor.name)||"observe"in e||"unobserve"in e||"revoke"in e)){return new s({target:e,ownKey:null,parent:null}).proxy}if(!e||"object"!=typeof e)throw new Error("observable MAY ONLY be created from non-null object only");if("observe"in e||"unobserve"in e||"revoke"in e)throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: "observe", "unobserve", "revoke"');if(t.hasOwnProperty(e.constructor.name))throw new Error(e+" found to be one of non-observable object types: "+t)}}Object.freeze(n);export default n;